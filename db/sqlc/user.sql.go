// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: user.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    username,
    hashed_password,
    full_name,
    email
) VALUES (
    $1, $2, $3, $4
) RETURNING username, hashed_password, full_name, email, password_changed_at, created_at
`

type CreateUserParams struct {
	Username       string `json:"username"`
	HashedPassword string `json:"hashed_password"`
	FullName       string `json:"full_name"`
	Email          string `json:"email"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Username,
		arg.HashedPassword,
		arg.FullName,
		arg.Email,
	)
	var i User
	err := row.Scan(
		&i.Username,
		&i.HashedPassword,
		&i.FullName,
		&i.Email,
		&i.PasswordChangedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT username, hashed_password, full_name, email, password_changed_at, created_at FROM users
WHERE username = $1 LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, username)
	var i User
	err := row.Scan(
		&i.Username,
		&i.HashedPassword,
		&i.FullName,
		&i.Email,
		&i.PasswordChangedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserWithProducts = `-- name: GetUserWithProducts :one
SELECT username, hashed_password, full_name, email, password_changed_at, created_at, products FROM users_with_products
WHERE username = $1 LIMIT 1
`

func (q *Queries) GetUserWithProducts(ctx context.Context, username string) (UsersWithProduct, error) {
	row := q.db.QueryRowContext(ctx, getUserWithProducts, username)
	var i UsersWithProduct
	var productsJSON string
	err := row.Scan(
		&i.Username,
		&i.HashedPassword,
		&i.FullName,
		&i.Email,
		&i.PasswordChangedAt,
		&i.CreatedAt,
		&productsJSON,
	)
	if err != nil {
		return UsersWithProduct{}, err
	}

	err = json.Unmarshal([]byte(productsJSON), &i.Products)
    if err != nil {
        return UsersWithProduct{}, err
    }
	return i, err
}

const listUserWithProducts = `-- name: ListUserWithProducts :many
SELECT username, hashed_password, full_name, email, password_changed_at, created_at, products FROM users_with_products
ORDER BY created_at
LIMIT $1
OFFSET $2
`

type ListUserWithProductsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListUserWithProducts(ctx context.Context, arg ListUserWithProductsParams) ([]UsersWithProduct, error) {
    rows, err := q.db.QueryContext(ctx, listUserWithProducts, arg.Limit, arg.Offset)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    var users []UsersWithProduct

    for rows.Next() {
        var user UsersWithProduct
        var productsJSON sql.NullString

        if err := rows.Scan(
            &user.Username,
            &user.HashedPassword,
            &user.FullName,
            &user.Email,
            &user.PasswordChangedAt,
            &user.CreatedAt,
            &productsJSON,
        ); err != nil {
            return nil, err
        }

        // Cek apakah productsJSON.Valid, jika tidak valid, set products menjadi array kosong
        if !productsJSON.Valid {
            user.Products = []Product{} // Set products menjadi array kosong
        } else {
            // Unmarshal JSON ke dalam slice produk jika ada data JSON yang valid
            var products []Product
            err := json.Unmarshal([]byte(productsJSON.String), &products)
            if err != nil {
                return nil, err
            }

            user.Products = products
        }

        users = append(users, user)
    }

    if err := rows.Err(); err != nil {
        return nil, err
    }

    return users, nil
}

